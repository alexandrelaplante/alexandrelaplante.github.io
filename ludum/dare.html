<html>
   <head>
      <title>Ludum Dare 31</title>
      <style>
         body { margin: 0; }
         canvas { width: 100%; height: 100% }
      </style>
   </head>
   <body>
      <script src="three.min.js"></script>
      <script src="tween.min.js"></script>
      <script>
         var scene = new THREE.Scene();
         var camera = new THREE.PerspectiveCamera( 30, window.innerWidth/window.innerHeight, 0.1, 1000 );
         var renderer = new THREE.WebGLRenderer();
         camera.aspect = window.innerWidth / window.innerHeight;
         camera.fov = 30;
         if (camera.aspect < 1){ camera.fov = 30/camera.aspect; }
         camera.updateProjectionMatrix();
         renderer.setSize( window.innerWidth, window.innerHeight );
         renderer.setSize( window.innerWidth, window.innerHeight );
         document.body.appendChild( renderer.domElement );

         var table_geo = new THREE.BoxGeometry( 10, 10, 0 );
         var table_mat = new THREE.MeshBasicMaterial( { color: 0xaaaaaa } );
         var table = new THREE.Mesh( table_geo, table_mat );
         scene.add( table );

         var plane_geo  = new THREE.BoxGeometry( 12, 12, 0 );
         var card_plane = new THREE.Mesh( plane_geo, table_mat );
         card_plane.position.z = 0.1;
         card_plane.visible=false;
         scene.add( card_plane );
         var space_h = 1.3;
         var space_w = 1.01;

         function new_space(x,y){
            var space_geo = new THREE.BoxGeometry( 1.01, 1.3, 0 );
            var space_mat = new THREE.MeshBasicMaterial(
               { color: 0xaaaaaa, opacity:0.15, transparent:true }
               );
            var space = new THREE.Mesh( space_geo, space_mat );
            space.position.set(x,y,0.05);
            scene.add(space);
            return space;
         }

         var spaces = [];
         for (i=-2; i<=2; i++){
            for (j=-2; j<=2; j++){
               var shade = Math.abs((i+j)%2);
               space = new_space(i*space_w,j*space_h );
               space.bluecolor = {r:0.2+0.1*shade,g:0.1+0.1*shade,b:0.8};
               space.basecolor = space.bluecolor;
               space.material.color = space.basecolor;
               space.i = i;
               space.j = j;
               spaces.push(space);
            }   
         }

         function neighbors_of(space){
            var neighbors = [];
            for (k in spaces){
               var n = spaces[k];
               if ((n.i == space.i-1 && n.j == space.j) ||
                   (n.i == space.i+1 && n.j == space.j) ||
                   (n.i == space.i && n.j == space.j-1) ||
                   (n.i == space.i && n.j == space.j+1) ){
                  neighbors.push(n);
               }
            }
            return neighbors;
         }

         window.center = new THREE.Vector3( 0, -1, 0 );

         num_mats = [];
         for (i=0; i<=9; i++){
            //create image
            var bitmap = document.createElement('canvas');
            var g = bitmap.getContext('2d');
            bitmap.width = 100;
            bitmap.height = 100;
            g.font = 'Bold 100px Arial';

            g.fillStyle = 'white';
            g.fillText(i, 22, 80);
            g.strokeStyle = 'black';
            g.strokeText(i, 22, 80);

            // canvas contents will be used for a texture
            var texture = new THREE.Texture(bitmap) 
            texture.needsUpdate = true;
            var num_mat = new THREE.MeshBasicMaterial({
               color: 0xffffff,
               transparent: true,
               map: texture,
            });
            num_mats.push(num_mat);
         }

         var card_geo = new THREE.BoxGeometry( 0.71, 1, 0 );
         var card_mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            map: THREE.ImageUtils.loadTexture('pokemon3.png'),
         });
         var num_geo = new THREE.BoxGeometry( 0.2, 0.2, 0 );

         function new_card(x,y, facing, attack, defence){
            var card = new THREE.Mesh( card_geo, card_mat );
            card.attack = attack;
            card.defence = defence;
            card.x = x;
            card.y = y;
            card.facing = 3.14*facing;
            card.control = !facing;
            card.permission = true;//card.control;
            card.position.set(card.x,card.y,0.1);
            card.rotation.set(0,0,card.facing);
            scene.add(card);

            card.num1 = new THREE.Mesh( num_geo, num_mats[attack] );
            card.num2 = new THREE.Mesh( num_geo, num_mats[defence] );
            scene.add(card.num1);
            scene.add(card.num2);

            card.num1update = function(){
               var above = new THREE.Vector3(0,0,1).applyEuler(card.rotation).multiplyScalar(0.1);
               card.num1.position.copy(card.position).add(above);
               card.num1.position.x -= 0.17;
               card.num1.position.y -= 0.4;
               card.num1.rotation.copy(camera.rotation);
            }
            card.num2update = function(){
               var above = new THREE.Vector3(0,0,1).applyEuler(card.rotation).multiplyScalar(0.1);
               card.num2.position.copy(card.position).add(above);
               card.num2.position.x += 0.17;
               card.num2.position.y -= 0.4;
               card.num2.rotation.copy(camera.rotation);
            }

            card.moveTo = function(position,rotation){
               card.tpos = {x:card.position.x, y:card.position.y, z:card.position.z,
                         rx:card.rotation.x, ry:card.rotation.y, rz:card.rotation.z};
               card.targ = {x:position.x, y:position.y, z:position.z,
                        rx:rotation.x, ry:rotation.y, rz:rotation.z};
               card.tween = new TWEEN.Tween(card.tpos).to(card.targ,300);
               card.tween.onUpdate(function(){
                  card.position.set(card.tpos.x, card.tpos.y, card.tpos.z);
                  card.rotation.set(card.tpos.rx, card.tpos.ry, card.tpos.rz);
               });
               card.tween.easing(TWEEN.Easing.Circular.Out);
               card.tween.start();
            }

            card.showcase = function(){
               if (card.showcased){
                  card.showcased = false;
                  card.return();
               } else {
                  // move to the showcase position
                  card.showcased = true;
                  // The new position will be right in front of the camera
                  var new_pos = window.center.clone().sub(camera.position).normalize().multiplyScalar(75/camera.fov).add(camera.position);
                  card.moveTo(new_pos, camera.rotation);
               }
               
            };
            card.return = function(){
               card.showcased = false;
               card.moveTo(new THREE.Vector3(card.x,card.y,0.1), new THREE.Vector3(0,0,card.facing));
            };

            return card;
         }

         var cards = [
            new_card(-1.6,-4, false, 1,1),
            new_card(-0.8,-4, false, 2,2),
            new_card(0,   -4, false, 3,3),
            new_card(0.8, -4, false, 1,4),
            new_card(1.6, -4, false, 4,1),

            new_card(-1.6, 4,  true, 1,2),
            new_card(-0.8, 4,  true, 2,2),
            new_card(0,    4,  true, 3,3),
            new_card(0.8,  4,  true, 1,4),
            new_card(1.6,  4,  true, 4,1),
         ];

         camera.position.set(0,-10,6);
         camera.lookAt( window.center );

         var raycaster = new THREE.Raycaster();

         document.addEventListener( 'mousedown', onDocumentMouseDown, false );
         document.addEventListener( 'mouseup',   onDocumentMouseUp, false );
         document.addEventListener( 'mousemove', onDocumentMouseMove, false );
         document.addEventListener( 'touchstart', onDocumentMouseDown, false );
         document.addEventListener( 'touchend',   onDocumentMouseUp, false );
         document.addEventListener( 'touchmove', onDocumentMouseMove, false );
         document.addEventListener("mousewheel", MouseWheelHandler, false);
         document.addEventListener("DOMMouseScroll", MouseWheelHandler, false);// Firefox
         window.addEventListener( 'resize', onWindowResize, false );

         function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            camera.fov = 30;
            if (camera.aspect < 1){ camera.fov = 30/camera.aspect; }
            renderer.setSize( window.innerWidth, window.innerHeight );
         }

         function MouseWheelHandler( event ) {
            camera.position.z = Math.max(0.2, camera.position.z + 0.2*(event.detail || event.wheelDelta));
            camera.lookAt( window.center );
         }

         window.space = undefined;
         window.card = undefined;
         window.moved = false;

         function onDocumentMouseDown( event ) {
            event.preventDefault();
            var inter = intersection(event, cards);
            if (inter){
               var card = inter.object;
               card.offset = inter.point.clone().sub( card.position );
               window.card = card;
            }
         }

         function onDocumentMouseMove( event ) {
            event.preventDefault();

            if (window.card && window.card.permission){
               new_pos = intersection(event, [card_plane]).point.sub(window.card.offset);
               new_pos.z+=0.01; // so it's above the other cards while dragging
               window.card.position.copy( new_pos );
               window.moved = true;

               for (i in spaces){
                  spaces[i].material.opacity = 0.15;
                  spaces[i].material.color = spaces[i].basecolor;
               }

               var inter = intersection(event, spaces);
               if (inter){
                  window.space = inter.object;
                  window.space.material.opacity = 0.4;
                  ns = neighbors_of(window.space);
                  for (i in ns){
                     ns[i].material.opacity = 0.3;
                     ns[i].material.color = {r:0.7, g:0.1, b:0.3};
                  }
               } else {
                  window.space = undefined;
               }
            }
         }

         function onDocumentMouseUp( event ) {
            event.preventDefault();
            var card = intersection(event, cards).object;
            if (!window.moved && card && window.card == card){
               card.showcase();
            } else if (window.moved) {
               card.return();
            }
            if (window.space){
               place(card, window.space);
               computer_turn();
            }
            for (i in spaces){
               spaces[i].material.opacity = 0.15;
               spaces[i].material.color = spaces[i].basecolor;
            }
            window.space = undefined;
            window.card = undefined;
            window.moved = false;
         }

         function place(card, space){
            card.x = space.position.x;
            card.y = space.position.y;
            card.space = space;
            space.card = card;
            if (card.control){
               space.basecolor = {r:0.3, g:1.0, b:0.3};
            } else {
               space.basecolor = {r:1.0, g:0.3, b:0.3};
            }
            neighbors = neighbors_of(space);
            for (i in neighbors){
               var ncard = neighbors[i].card;
               if (ncard && ncard.control !== card.control){
                  ncard.defence = Math.max(0, ncard.defence-card.attack);
                  scene.remove(ncard.num2);
                  ncard.num2 = new THREE.Mesh( num_geo, num_mats[ncard.defence] );
                  scene.add(ncard.num2);
                  if (ncard.defence == 0){
                     ncard.x = 3.2;
                     ncard.y = 0;
                     ncard.facing = -0.5*3.14;
                     ncard.return();
                     ncard.space.basecolor = ncard.space.bluecolor;
                     ncard.space.card = undefined;
                     ncard.space = undefined;
                     ncard.dead = true;
                  }
               }
            }
            card.permission = false;
            card.return();
         }

         function computer_turn(){
            a = {x:0}; b = {x:1}
            tween = new TWEEN.Tween(a).to(b,500);
            tween.onComplete(function(){

               var hand = [];
               for (i in cards){
                  if (cards[i].control === false && !cards[i].space && !cards[i].dead){
                     hand.push(cards[i]);
                  }
               }
               var choice = Math.round((hand.length-1)*Math.random());
               var card = hand[choice];

               for (i in spaces){
                  if (! spaces[i].card){
                     choice = i;
                  }
               }

               place(card, spaces[choice]);

               for (i in spaces){
                  spaces[i].material.opacity = 0.15;
                  spaces[i].material.color = spaces[i].basecolor;
               }

            });
            tween.start();
         }

         function intersection(event, objects){
            // if it's a touch event, check event.changedTouches[0].clientX
            if (event.changedTouches){ 
               event.clientX = event.changedTouches[0].clientX;
               event.clientY = event.changedTouches[0].clientY;
            }

            var mouse = new THREE.Vector2();
            mouse.x =  (event.clientX / window.innerWidth)*2 - 1;
            mouse.y = -(event.clientY / window.innerHeight)*2 + 1;
            var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

            raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

            var intersects = raycaster.intersectObjects( objects );

            if ( intersects.length > 0 ) {
               return intersects[ 0 ];
            }
         }


         var render = function () {
            for (i in cards){
               cards[i].num1update();
               cards[i].num2update();
            }
            TWEEN.update();
            requestAnimationFrame( render );
            renderer.render(scene, camera);
         };
         render();
      </script>
   </body>
</html>