<html>
    <head>
        <title>Ludum Dare 31</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="three.min.js"></script>
        <script src="tween.min.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 30, window.innerWidth/window.innerHeight, 0.1, 1000 );
            var renderer = new THREE.WebGLRenderer();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.fov = 30;
            if (camera.aspect < 1){ camera.fov = 30/camera.aspect; }
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            var table_geo = new THREE.BoxGeometry( 10, 10, 0 );
            var table_mat = new THREE.MeshBasicMaterial( { color: 0xaaaaaa } );
            var table = new THREE.Mesh( table_geo, table_mat );
            scene.add( table );

            var plane_geo  = new THREE.BoxGeometry( 12, 12, 0 );
            var card_plane = new THREE.Mesh( plane_geo, table_mat );
            card_plane.position.z = 0.1;
            card_plane.visible=false;
            scene.add( card_plane );
            var space_h = 1.3;
            var space_w = 1.01;

            function new_space(x,y){
                var space_geo = new THREE.BoxGeometry( 1.01, 1.3, 0 );
                var space_mat = new THREE.MeshBasicMaterial(
                    { color: 0xaaaaaa, opacity:0.15, transparent:true }
                    );
                var space = new THREE.Mesh( space_geo, space_mat );
                space.position.set(x,y,0.05);
                scene.add(space);
                return space;
            }

            var spaces = [];
            for (i=-2; i<=2; i++){
                for (j=-2; j<=2; j++){
                    var shade = Math.abs((i+j)%2);
                    space = new_space(i*space_w,j*space_h );
                    space.material.color = {r:0.2+0.1*shade,g:0.1+0.1*shade,b:0.8};
                    spaces.push(space);
                }   
            }

            window.center = new THREE.Vector3( 0, -1, 0 );

            num_mats = [];
            for (i=0; i<=9; i++){
                //create image
                var bitmap = document.createElement('canvas');
                var g = bitmap.getContext('2d');
                bitmap.width = 100;
                bitmap.height = 100;
                g.font = 'Bold 100px Arial';

                g.fillStyle = 'white';
                g.fillText(i, 22, 80);
                g.strokeStyle = 'black';
                g.strokeText(i, 22, 80);

                // canvas contents will be used for a texture
                var texture = new THREE.Texture(bitmap) 
                texture.needsUpdate = true;
                var num_mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    map: texture,
                });
                num_mats.push(num_mat);
            }

            var card_geo = new THREE.BoxGeometry( 0.71, 1, 0 );
            var card_mat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                map: THREE.ImageUtils.loadTexture('pokemon2.jpg'),
            });
            var num_geo = new THREE.BoxGeometry( 0.2, 0.2, 0 );
            function new_card(x,y, facing){
                var card = new THREE.Mesh( card_geo, card_mat );
                card.x = x;
                card.y = y;
                card.facing = 3.14*facing;
                card.position.set(card.x,card.y,0.1);
                card.rotation.set(0,0,card.facing);
                scene.add(card);

                card.num1 = new THREE.Mesh( num_geo, num_mats[Math.round(9*Math.random())] );
                card.num2 = new THREE.Mesh( num_geo, num_mats[Math.round(9*Math.random())] );
                scene.add(card.num1);
                scene.add(card.num2);

                card.num1.update = function(){
                    var above = new THREE.Vector3(0,0,1).applyEuler(card.rotation).multiplyScalar(0.1);
                    card.num1.position.copy(card.position).add(above);
                    card.num1.position.x -= 0.17;
                    card.num1.position.y -= 0.4;
                    card.num1.rotation.copy(camera.rotation);
                }
                card.num2.update = function(){
                    var above = new THREE.Vector3(0,0,1).applyEuler(card.rotation).multiplyScalar(0.1);
                    card.num2.position.copy(card.position).add(above);
                    card.num2.position.x += 0.17;
                    card.num2.position.y -= 0.4;
                    card.num2.rotation.copy(camera.rotation);
                }

                card.moveTo = function(position,rotation){
                    card.tpos = {x:card.position.x, y:card.position.y, z:card.position.z,
                                 rx:card.rotation.x, ry:card.rotation.y, rz:card.rotation.z};
                    card.targ = {x:position.x, y:position.y, z:position.z,
                                rx:rotation.x, ry:rotation.y, rz:rotation.z};
                    card.tween = new TWEEN.Tween(card.tpos).to(card.targ,300);
                    card.tween.onUpdate(function(){
                        card.position.set(card.tpos.x, card.tpos.y, card.tpos.z);
                        card.rotation.set(card.tpos.rx, card.tpos.ry, card.tpos.rz);
                    });
                    card.tween.easing(TWEEN.Easing.Circular.Out);
                    card.tween.start();
                }

                card.showcase = function(){
                    if (card.showcased){
                        card.showcased = false;
                        card.return();
                    } else {
                        // move to the showcase position
                        card.showcased = true;
                        // The new position will be right in front of the camera
                        var new_pos = window.center.clone().sub(camera.position).normalize().multiplyScalar(75/camera.fov).add(camera.position);
                        card.moveTo(new_pos, camera.rotation);
                    }
                    
                };
                card.return = function(){
                    card.showcased = false;
                    card.moveTo(new THREE.Vector3(card.x,card.y,0.1), new THREE.Vector3(0,0,card.facing));
                };

                return card;
            }

            var cards = [
                new_card(-1.6,-4, false),
                new_card(-0.8,-4, false),
                new_card(0,   -4, false),
                new_card(0.8, -4, false),
                new_card(1.6, -4, false),
                new_card(3.2,    0,   -0.5),
                new_card(-1.6, 4, true),
                new_card(-0.8, 4, true),
                new_card(0,    4, true),
                new_card(0.8,  4, true),
                new_card(1.6,  4, true),
            ];

            camera.position.set(0,-10,6);
            camera.lookAt( window.center );

            var raycaster = new THREE.Raycaster();

            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'mouseup',   onDocumentMouseUp, false );
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'touchstart', onDocumentMouseDown, false );
            document.addEventListener( 'touchend',   onDocumentMouseUp, false );
            document.addEventListener( 'touchmove', onDocumentMouseMove, false );
            document.addEventListener("mousewheel", MouseWheelHandler, false);
            document.addEventListener("DOMMouseScroll", MouseWheelHandler, false);// Firefox
            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                camera.fov = 30;
                if (camera.aspect < 1){ camera.fov = 30/camera.aspect; }
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function MouseWheelHandler( event ) {
                if (event){
                    camera.position.z = Math.max(0.2, camera.position.z + 0.2*(event.detail || event.wheelDelta));
                }
                camera.lookAt( window.center );
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();
                var inter = intersection(event, cards);
                if (inter){
                    window.card = inter.object;
                    window.card.offset = inter.point.clone().sub( window.card.position );
                }
            }

            function onDocumentMouseMove( event ) {
                event.preventDefault();

                if (window.card){
                    new_pos = intersection(event, [card_plane]).point.sub(window.card.offset);
                    new_pos.z+=0.01; // so it's above the other cards while dragging
                    window.card.position.copy( new_pos );
                    window.moved = true;

                    for (i in spaces){
                        spaces[i].material.opacity = 0.15;
                    }

                    var inter = intersection(event, spaces);
                    if (inter){
                        window.space = inter.object;
                        window.space.material.opacity = 0.4;
                    } else {
                        window.space = undefined;
                    }
                }
                
            }

            function onDocumentMouseUp( event ) {
                event.preventDefault();
                var card = intersection(event, cards).object;
                if (!window.moved && card && window.card == card){
                    card.showcase();
                } else if (window.moved) {
                    card.return();
                }
                if (window.space){
                    card.x = window.space.position.x;
                    card.y = window.space.position.y;
                    card.space = window.space;
                    window.space.card = card;
                    card.space.material.color = {r:0.3, g:1.0, b:0.3};
                    card.return();
                }
                for (i in spaces){
                    spaces[i].material.opacity = 0.15;
                }
                window.space = undefined;
                window.card = undefined;
                window.moved = false;
            }

            function intersection(event, objects){
                // if it's a touch event, check event.changedTouches[0].clientX
                if (event.changedTouches){ 
                    event.clientX = event.changedTouches[0].clientX;
                    event.clientY = event.changedTouches[0].clientY;
                }

                var mouse = new THREE.Vector2();
                mouse.x =  (event.clientX / window.innerWidth)*2 - 1;
                mouse.y = -(event.clientY / window.innerHeight)*2 + 1;
                var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

                raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

                var intersects = raycaster.intersectObjects( objects );

                if ( intersects.length > 0 ) {
                    return intersects[ 0 ];
                }
            }


            var render = function () {
                for (i in cards){
                    cards[i].num1.update();
                    cards[i].num2.update();
                }
                TWEEN.update();
                requestAnimationFrame( render );
                renderer.render(scene, camera);
            };
            render();
        </script>
    </body>
</html>